#include <iostream>
#include <fstream>
#include "StudentsGroup.pb.h"


using namespace std;

//========================================================================================================================================
//Task 2. Protobuf classes
//========================================================================================================================================
/*
С помощью компилятора protobuf в отдельном пространстве имен сгенерировать классы :
a.FullName с полями имя, фамилия, отчество(отчество опционально).
b.Student с полями полное имя, массив оценок, средний балл.
c.StudentsGroup с полем массив студентов.
*/

//========================================================================================================================================
//Task 3. Interface classes
//========================================================================================================================================
/*
Создать класс StudentsGroup (не используя protobuf (namespaces??)), который реализует интерфейсы:
*/

class IRepository
{
	virtual void Open() = 0; // бинарная десериализация в файл
	virtual void Save() = 0; // бинарная сериализация в файл
};

class IMethods
{
	virtual double GetAverageScore(const Students::FullName& name) = 0;
	virtual string GetAllInfo(const Students::FullName& name) = 0;
	virtual string GetAllInfo() = 0;
};


int main()
{
	system("chcp 1251");
	//========================================================================================================================================
	//Task 2. Protobuf classes
	//========================================================================================================================================
	
	{
		//some tests of classes generated by protobuf
		Students::StudentsGroup TestGroup;
		Students::Student student1;
		Students::FullName name1;

		void (Students::Student::* av_mark_ptr)(double _val) = &Students::Student::set_average_mark;
		void (Students::Student::* add_mark_ptr)(int _pos, int _val) = &Students::Student::set_marks;

		name1.set_name("Tim");
		name1.set_surname("Kor");
		name1.set_middle_name("Vad");
		*student1.mutable_name() = name1;
		student1.mutable_name()->set_name("T");

		student1.add_marks(0);
		student1.add_marks(1);
		student1.add_marks(2);

		student1.set_marks(0, 5);
		(student1.*add_mark_ptr)(1, 4);
		(student1.*add_mark_ptr)(2, 5);

		(student1.*av_mark_ptr)(static_cast<double>((student1.marks(0) + student1.marks(1) + student1.marks(2)))/3 );
		

		TestGroup.add_student_group();
		*TestGroup.mutable_student_group(0) = student1;
		TestGroup.mutable_student_group(0)->mutable_name()->set_name("Ti");

		//checking if TestGroup was assembled correctly
		{
		cout << "Имя студента: " << TestGroup.student_group(0).name().name() << " " << TestGroup.student_group(0).name().surname() << " " << ((TestGroup.student_group(0).name().has_middle_name()) ? (TestGroup.student_group(0).name().middle_name()) : ("")) << endl;
		cout << "Оценки студента: " << student1.marks(0) << " " << student1.marks(1) << " " << student1.marks(2) << endl;
		cout << "Средняя оценка: " << TestGroup.student_group(0).average_mark() << endl;
		}

		ofstream out("test.bin", ios_base::binary);
		TestGroup.SerializeToOstream(&out);
		out.close(); //does not read properly without it!!

		ifstream in("test.bin", ios_base::binary);
		Students::StudentsGroup TestGroup2;
		bool check = TestGroup2.ParsePartialFromIstream(&in);
		cout << boolalpha << check << endl;
		cout << "Средняя оценка: " << TestGroup2.student_group(0).average_mark() << endl;
		in.close();

		google::protobuf::ShutdownProtobufLibrary();  // Optional:  Delete all global objects allocated by libprotobuf.
	}


	//========================================================================================================================================
	//Task 3. Interface classes
	//========================================================================================================================================


	return 0;
}
